package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/k0kubun/pp"
	"io"
	"log"
	"math/rand"
	"net/http"
	"os"
	"path"
	"slices"
	"strings"
	"sync/atomic"
	"time"
)

type jsonMap = map[string]any

var filename = "" // copy ndjson to this directory and enter filename here, e.g. "file.ndjson"

type fieldAttrsResult struct {
	title      string
	name       string
	fieldAttrs jsonMap
}

func (f *fieldAttrsResult) Equal(other *fieldAttrsResult) bool {
	if f.title != other.title || f.name != other.name || len(f.fieldAttrs) != len(other.fieldAttrs) {
		return false
	}
	for k := range f.fieldAttrs { // we only compare keys
		if _, ok := other.fieldAttrs[k]; !ok {
			return false
		}
	}
	return true
}

var fieldAttrsResults []fieldAttrsResult

var keysWithNestedJsonsAsStrings = []string{ /*"optionsJSON", */ "panelsJSON", "fieldAttrs"}
var interestingKeys = []string{"attributes", "match_phrase", "text", "formula", "query", "field", "sourceField", "index_pattern", "fieldAttrs", "title", "name"}

func scanOneFile() error {
	file, err := os.Open(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		var j jsonMap
		if err = json.Unmarshal([]byte(line), &j); err != nil {
			return err
		}
		if err = processJson(j); err != nil {
			return err
		}
	}
	return nil
}

func parseNdJson(s string) []jsonMap {
	var jsons []jsonMap
	var printDebug = false
	d := json.NewDecoder(strings.NewReader(s))
	for {
		// Decode one JSON document.
		var v any
		err := d.Decode(&v)

		if err != nil {
			// io.EOF is expected at end of stream.
			if err != io.EOF {
				fmt.Println("Error decoding JSON: ", err)
			}
			break
		}

		// Do something with the value.
		// fmt.Println(v)
		//for k, v := range v.([]any) {
		//	fmt.Println(k, v)
		//}
		switch vv := v.(type) {
		case jsonMap:
			if printDebug {
				fmt.Println("parseNdJson jsonMap:", vv)
			}
			jsons = append(jsons, vv)
		case []any:
			if printDebug {
				pp.Println("parseNdJson []any", vv)
			}
			for _, vvv := range vv {
				if j, ok := vvv.(jsonMap); ok {
					jsons = append(jsons, j)
				}
			}
		}
	}
	return jsons
}

func processJson(j jsonMap) error {
	fieldAttrs, hasFieldAttrs := j["fieldAttrs"]
	title, hasTitle := j["title"].(string)
	name, hasName := j["name"].(string)

	if hasFieldAttrs {
		/*
			if hasTitle || hasName {
				pp.Printf("====== VIP processJson ======\n===, title: %v, name: %v, fieldAttrs:\n%v", title, name, fieldAttrs)
			} else {
				pp.Println("====== VIP processJson, fieldAttrs:", fieldAttrs)
			}

		*/
		var dict map[string]interface{}
		err := json.Unmarshal([]byte(fieldAttrs.(string)), &dict)
		if err != nil {
			panic(err)
		}
		var keys []string
		for k := range dict {
			keys = append(keys, k)
		}
		slices.Sort(keys)

		/*
			for _, k := range keys {
				fmt.Println("-", k, ",", dict[k])
			}
		*/

		thisTableResult := fieldAttrsResult{fieldAttrs: dict}
		if hasTitle {
			thisTableResult.title = title
		}
		if hasName {
			thisTableResult.name = name
		}
		if len(fieldAttrsResults) == 0 || !fieldAttrsResults[len(fieldAttrsResults)-1].Equal(&thisTableResult) {
			fieldAttrsResults = append(fieldAttrsResults, thisTableResult)
		}
	}

	for k, v := range j {

		if slices.Contains(keysWithNestedJsonsAsStrings, k) {
			//fmt.Println("--- processJson, in keysWithNestedJsonsAsStrings, key:", k, "val:", v)
			var ndJson []jsonMap
			if k == "panelsJSON" {
				ndJson = parseNdJson(v.(string))
			} else {
				ndJson = parseNdJson(v.(string))
			}
			for _, js := range ndJson {
				// pp.Println(js)
				if err := processJson(js); err != nil {
					return err
				}
			}
		}
		if slices.Contains(interestingKeys, k) {
			dataType := j["dataType"]
			if _, ok := v.(string); ok {
				if v.(string) != "" {
					processInteresting(k, v, dataType)
				}
			} else {
				processInteresting(k, v, dataType)
			}
		}
		if nestedJson, ok := v.(jsonMap); ok {
			// fmt.Println(k, "hoho")
			if err := processJson(nestedJson); err != nil {
				return err
			}
		} else if va, ok := v.([]any); ok {
			for vaa := range va {
				err := processJson(jsonMap{"k_nested": vaa})
				if err != nil {
					return err
				}
			}
		} else {
			switch v.(type) {
			case string, int, float64, bool:
			default:
				//pp.Printf("ERROR: %s %T %v\n", k, v, v)
				errors = append(errors, fmt.Sprintf("ERROR: %s %T %v", k, v, v))
			}
		}
	}
	return nil
}

var formulas = make(map[string]struct{})
var sourceFields = make(map[string]struct{})
var queries = make(map[string]struct{})
var errors = make([]string, 0)

func processInteresting(key string, value, dataType any) {
	switch key {
	case "sourceField":
		processSourceField(key, value, dataType)
	case "formula", "text":
		processFormula(key, value, dataType)
	case "query":
		processQuery(key, value, dataType)
	case "attributes":
		//fmt.Println("processJson from attributes")
		processJson(value.(jsonMap))
	default:
		//fmt.Println("processInteresting, default case, key:", key, value, dataType)
	}
}

func processSourceField(key string, value, dataType any) {
	if _, ok := value.(string); !ok {
		//pp.Println(key, value, dataType)
		errors = append(errors, fmt.Sprintf("sourceField is not a string: %v", value))
		return
	}

	dtIsNil := dataType == nil
	_, dtIsStr := dataType.(string)
	if !dtIsStr && !dtIsNil {
		//pp.Println(key, value, dataType)
		errors = append(errors, fmt.Sprintf("dataType is not a string: %v", dataType))
		return
	}
	dtString := ""
	if dtIsStr && dataType.(string) != "" {
		dtString = "|" + dataType.(string)
	}
	sourceFields[value.(string)+dtString] = struct{}{}
}

func processFormula(key string, value, dataType any) {
	if _, ok := value.(string); !ok {
		//pp.Println("processFormula key:", key, "value:", value, "dataType:", dataType)
		errors = append(errors, fmt.Sprintf("formula is not a string: %v", value))
		return
	}
	if dataType != nil {
		//pp.Println("processFormula key:", key, "value:", value, "dataType:", dataType)
		errors = append(errors, fmt.Sprintf("dataType is not nil: %v", dataType))
		return
	}
	formulas[value.(string)] = struct{}{}
}

func processQuery(key string, value, dataType any) {
	//pp.Println("--- processQuery, key:", key)
	if valueAsMap, ok := value.(jsonMap); ok {
		// we skip <=> len == 2, and there are 2 keys: 'query' == "", and 'language'
		weCanSkip := len(valueAsMap) == 2
		if query, exists := valueAsMap["query"]; !exists || query.(string) != "" {
			weCanSkip = false
		}
		if _, exists := valueAsMap["language"]; !exists {
			weCanSkip = false
		}
		if weCanSkip {
			return
		}
		//pp.Println("processQuery key:", key, "value:", value, "dataType:", dataType)
		errors = append(errors, fmt.Sprintf("query is a map: %v", value))
	}

	if dataType != nil {
		//pp.Println("processQuery key:", key, "value:", value, "dataType:", dataType)
		errors = append(errors, fmt.Sprintf("dataType is not nil: %v", dataType))
		return
	}

	if _, ok := value.(string); !ok {
		//pp.Println("processQuery key:", key, "value:", value, "dataType:", dataType)
		errors = append(errors, fmt.Sprintf("query is not a string: %v", value))
		return
	}

	queries[value.(string)] = struct{}{}
}

func printSourceFields() {
	if len(sourceFields) > 0 {
		//pp.Println("sourceFields:")
		for k := range sourceFields {
			sf := strings.Split(k, "|")
			switch len(sf) {
			case 1:
				fmt.Printf("  * %s\n", k)
			case 2:
				fmt.Printf("  * %s\t%s\n", sf[0], sf[1])
			default:
				pp.Println("ERROR\n")
			}
		}
	}
}

func printFormulas() {
	if len(formulas) > 0 {
		pp.Println("formulas:")
		for k := range formulas {
			fmt.Printf("  * %s\n", k)
		}
	}
}

func printQueries() {
	if len(formulas) > 0 {
		pp.Println("queries:")
		for k := range formulas {
			fmt.Printf("  * %s\n", k)
		}
	}
}

func printFieldAttrsResults(printAlsoValue bool) {
	fmt.Println("Printing fieldAttrs results:")
	if len(fieldAttrsResults) > 0 {
		pp.Println("fieldAttrsResults:, len:", len(fieldAttrsResults), "First 10:")

		var a []fieldAttrsResult
		if len(fieldAttrsResults) > 10 {
			a = fieldAttrsResults[:10]
		} else {
			a = fieldAttrsResults
		}

		for i, res := range a {
			fmt.Printf("%d. name: %v title: %v\n", i+1, res.name, res.title)

			var keys []string
			for k := range res.fieldAttrs {
				keys = append(keys, k)
			}
			slices.Sort(keys)

			for _, k := range keys {
				Type := "String"

				if k == "@timestamp" || k == "timestamp" || k == "date_from" || k == "date_to" {
					Type = "DateTime64(3)"
				}
				if printAlsoValue {
					fmt.Printf(`- "%s": %v`, k, res.fieldAttrs[k])
				} else {
					fmt.Printf(`"%s" Nullable(%s),`, k, Type)
				}
				fmt.Println()
			}
			fmt.Printf("\n\n")
		}
	}
}

type indexField struct {
	name     string
	dataType string
	dbType   string
}
type index struct {
	name    string
	pattern string
	fields  map[string]*indexField
}

var indexes = make(map[string]*index)

func process() {

	log.Println("results: ", len(fieldAttrsResults))

	if len(fieldAttrsResults) > 0 {

		for _, res := range fieldAttrsResults {
			//fmt.Printf("%d. name: %v title: %v\n", i+1, res.name, res.title)

			if res.name == "" {
				continue
			}

			name := res.name

			if strings.HasSuffix(name, "*") {
				name = strings.TrimSuffix(name, "*")
				name = name + "-1"
			}

			idx, ok := indexes[name]
			if !ok {
				idx = &index{name: name, fields: make(map[string]*indexField)}
				idx.pattern = res.name
				indexes[name] = idx
			}

			var keys []string
			for k := range res.fieldAttrs {
				keys = append(keys, k)
			}
			slices.Sort(keys)

			for _, k := range keys {

				if _, ok := idx.fields[k]; ok {
					continue
				}

				dbType := "String"
				elasticType := "keyword"

				if k == "@timestamp" || k == "timestamp" || k == "date_from" || k == "date_to" {
					dbType = "DateTime64(3)"
					elasticType = "date"
				}

				idx.fields[k] = &indexField{name: k, dataType: elasticType, dbType: dbType}

			}
		}
	}
}

type fieldMapping struct {
	Type string `json:"type"`
}

type indexMapping struct {
	Properties map[string]fieldMapping `json:"properties"`
}

func toMappings(idx index) indexMapping {
	m := indexMapping{Properties: make(map[string]fieldMapping)}
	for _, field := range idx.fields {
		m.Properties[field.name] = fieldMapping{Type: field.dataType}
	}
	return m
}

func getRandomValue(fieldType string) any {

	switch fieldType {
	case "boolean":
		return rand.Intn(2) == 1 // true or false
	case "constant_keyword", "keyword", "wildcard", "match_only_text":
		return fmt.Sprintf("random_string_%d", rand.Intn(1000)) // Random string
	case "date":
		return time.Now().Format("2006-01-02") // Random current date
	case "flattened":
		return map[string]string{
			"key": fmt.Sprintf("value_%d", rand.Intn(100)),
		} // Random flattened object
	case "float", "scaled_float":
		return rand.Float64() * 100 // Random float value
	case "geo_point":
		return map[string]float64{
			"lat": rand.Float64()*180 - 90,  // Latitude: -90 to 90
			"lon": rand.Float64()*360 - 180, // Longitude: -180 to 180
		}
	case "ip":
		return fmt.Sprintf("%d.%d.%d.%d",
			rand.Intn(256), rand.Intn(256), rand.Intn(256), rand.Intn(256)) // Random IPv4
	case "long":
		return rand.Int63n(1000000) // Random long integer
	case "nested", "object":
		return map[string]any{
			"nested_field": rand.Intn(100), // Nested object with random int
		}
	default:
		return nil // Unknown type
	}
}

var docCounter atomic.Int64

func generateDocumentInDay(t time.Time, idx index) ([]byte, error) {
	doc := make(map[string]interface{})
	for f, t := range idx.fields {
		doc[f] = getRandomValue(t.dataType)
	}

	t = t.Add(time.Duration(rand.Intn(24)) * time.Hour)
	t = t.Add(time.Duration(rand.Intn(60)) * time.Minute)

	doc["@timestamp"] = t.Format(time.RFC3339)
	doc["__number_of_fields"] = len(idx.fields)
	doc["__id"] = docCounter.Add(1)

	data, err := json.Marshal(doc)
	if err != nil {
		return nil, err
	}

	return data, nil
}

func callHTTP(method string, url string, payload []byte) ([]byte, error) {
	client := &http.Client{}
	req, err := http.NewRequest(method, url, bytes.NewBuffer(payload))

	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	resp, err := client.Do(req)
	if err != nil {
		return nil, err // Failed to send request
	}

	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Println("Failed to read response body:", err)
	}

	if resp.StatusCode != http.StatusOK {

		fmt.Println("Request URL:", method, url)
		fmt.Println("Response status:", resp.Status)
		fmt.Println("Response body:", string(body))

		return body, fmt.Errorf("unexpected status code: %d", resp.StatusCode)

	}
	return body, nil
}

func ingestData(idx index) {
	ts := time.Now()

	days := 5
	perDay := 10

	endpoint := "http://localhost:8080"

	for d := range days {
		startAt := ts.Add(-time.Duration(d) * 24 * time.Hour)
		startAt = startAt.Truncate(24 * time.Hour)

		indexName := idx.name
		if strings.HasSuffix(idx.pattern, "*") {
			dayPattern := startAt.Format("20060102")
			indexName = strings.TrimSuffix(idx.pattern, "*")
			indexName = fmt.Sprintf("%s%s", indexName, dayPattern)
		}

		bulkJson := fmt.Sprintf(`{"create":{"_index":"%s"}}`, indexName)

		var bulkPayload []byte
		log.Println("Generating bulk... Index:", indexName)
		for range perDay {

			doc, err := generateDocumentInDay(startAt, idx)
			if err != nil {
				fmt.Println(err)
				continue
			}

			bulkPayload = append(bulkPayload, []byte(bulkJson)...)
			bulkPayload = append(bulkPayload, []byte("\n")...)
			bulkPayload = append(bulkPayload, doc...)
			bulkPayload = append(bulkPayload, []byte("\n")...)
		}

		log.Println("Sending bulk... Index:", indexName, len(bulkPayload))
		_, err := callHTTP("POST", fmt.Sprintf("%s/_bulk", endpoint), bulkPayload)
		if err != nil {
			log.Println("Failed to send document:", err)
			continue
		}
	}
}

func main() {

	inputDir := "dashboards"

	log.Println("Starting...")
	entries, err := os.ReadDir(inputDir)
	if err != nil {
		log.Fatal(err)
	}

	for _, entry := range entries {

		if entry.IsDir() {
			continue
		}

		if !strings.HasSuffix(entry.Name(), ".ndjson") {
			continue
		}

		fieldAttrsResults = make([]fieldAttrsResult, 0)
		filename = path.Join(inputDir, entry.Name())

		log.Println("Processing", entry.Name())

		if err := scanOneFile(); err != nil {
			fmt.Println(err)
		}
		process()
	}
	//printSourceFields()
	//printFormulas()
	//printQueries()
	//printFieldAttrsResults(true)
	//printFieldAttrsResults(false)

	count := 0
	for _, idx := range indexes {
		log.Println(count, "-", idx.name, len(idx.fields))

		count++
		mappings := toMappings(*idx)
		b, err := json.MarshalIndent(mappings, "", "  ")
		if err != nil {
			log.Fatal(err)
		}
		fmt.Println(string(b))
		out := fmt.Sprintf("%s/%s.json", "mappings", idx.name)
		err = os.WriteFile(out, b, 0644)
		if err != nil {
			log.Println("Error writing file:", err)
		}
	}

	if len(errors) > 0 {
		//pp.Println("Errors:", errors)
	} else {
		fmt.Println("Done, no error! :)")
	}
}
